import math

import matplotlib.pyplot as plt
import pandas as pd

from household_contact_tracing.views.simulation_view import SimulationView
from household_contact_tracing.simulation_model import BranchingProcessModel
from household_contact_tracing.views.colors import node_colours


class TimelineGraphView(SimulationView):
    """
        Timeline View: A really simple proof-of-concept, could be used as a template.
        Shows how views are now decoupled from model code and each other.

        Attributes
        ----------
        _model (BranchingProcessModel): The branching process model who's data is being displayed to the user


        Methods
        -------

        set_display(self, display: bool)
            choose whether to show these 'shell' (text printouts) to the user

        graph_change(self, subject: BranchingProcessModel)
            Respond to changes in graph (nodes/households network)

        model_state_change(self, subject: BranchingProcessModel):
            Respond to changes in model state (e.g. running, extinct, timed-out)

        model_step_increment(self, subject: BranchingProcessModel):
            Respond to increment in simulation

        model_simulation_stopped(self, subject: BranchingProcessModel)
            Respond to end of simulation run

    """

    def __init__(self, model: BranchingProcessModel):
        self._model = model

        self.node_type_counts = pd.DataFrame(columns=[node.name for node in node_colours.keys()])

        # Register as observer
        self._model.register_observer_simulation_stopped(self)
        self._model.register_observer_step_increment(self)

    def set_display(self, show: bool):
        if show:
            self._model.register_observer_simulation_stopped(self)
            self._model.register_observer_step_increment(self)
        else:
            self._model.remove_observer_graph_change(self)
            self._model.remove_observer_step_increment(self)

    def model_state_change(self, subject: BranchingProcessModel):
        """ Respond to changes in model state (e.g. running, extinct, timed-out) """
        pass

    def graph_change(self, subject: BranchingProcessModel):
        """ Respond to changes in graph (nodes/households network) """
        pass

    def model_step_increment(self, subject: BranchingProcessModel):
        """ Respond to single step increment in simulation """
        self.increment_timeline(subject.network)

    def model_simulation_stopped(self, subject: BranchingProcessModel):
        self.draw_timeline()

    def draw_timeline(self):
        """ Draws the timeline graph, generated by the model."""
        colours = {node.name: colour.colour for node, colour in node_colours.items()}
        if len(self.node_type_counts.index):
            axes = self.node_type_counts.plot(subplots=True, legend=False,
                                              color=colours, figsize=(6, 14),
                                              layout=(math.ceil(len(colours)/2), 2),
                                              ylim=(0, self.node_type_counts.to_numpy().max()))
            for index, node_type in enumerate(self.node_type_counts.columns):
                title = node_type
                axes[index // 2][index % 2].set_title(title)
            plt.tight_layout()
            plt.show()

    def increment_timeline(self, network):
        node_counts = {node.name: network.count_nodes(node) for node in node_colours.keys()}
        self.node_type_counts = self.node_type_counts.append(node_counts, ignore_index=True)
