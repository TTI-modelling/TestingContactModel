import datetime

from pyvis.network import Network as pvNetwork
import networkx as nx
import os
import webbrowser
from bs4 import BeautifulSoup as bs

from household_contact_tracing.views.simulation_view import SimulationView
from household_contact_tracing.network import Network
from household_contact_tracing.simulation_model import BranchingProcessModel
from household_contact_tracing.views.colors import node_colours, edge_colours


class GraphPyvisView(SimulationView):
    """ Graph View using Pyvis library:
        https://pyvis.readthedocs.io/en/latest/tutorial.html
    """
    def __init__(self, model: BranchingProcessModel):
        # Viewers own copies of controller and model (MVC pattern)
        # ... but controller not required yet (no input collected from view)
        # self.controller = controller
        self.model = model

        self.filename = os.path.join(os.path.dirname(self.model.root_dir),
                                     'temp',
                                     'pyvis_graph_{}.html'.format(datetime.datetime.now().strftime("%Y%m%d-%H%M%S")))
        self._open_in_browser = False

        # Register as observer
        self.model.register_observer_state_change(self)
        self.model.register_observer_simulation_stopped(self)

    @property
    def open_in_browser(self):
        return self._open_in_browser

    @open_in_browser.setter
    def open_in_browser(self, open_in_browser: bool):
        self._open_in_browser = open_in_browser

    def set_display(self, show: bool):
        if show:
            self.model.register_observer_simulation_stopped(self)
        else:
            self.model.remove_observer_simulation_stopped(self)

    def model_param_change(self, subject):
        """ Respond to parameter change(s) """
        pass

    def model_state_change(self, subject):
        """ Respond to changes in model state (e.g. running, extinct, timed-out) """
        pass

    def model_step_increment(self, subject):
        """ Respond to single step increment in simulation """
        pass

    def model_simulation_stopped(self, subject: BranchingProcessModel):
        if self not in subject.observers_graph_change:
            self.draw_network(subject.network)

    def graph_change(self, subject: BranchingProcessModel):
        """ Respond to changes in graph (nodes/households network) """
        pass

    def set_show_all_graphs(self, show_all):
        if show_all:
            self.model.register_observer_graph_change(self)
        else:
            self.model.remove_observer_graph_change(self)

    def draw_network(self, network: Network):
        """Draws the network generated by the model."""

        nt = pvNetwork('1000px', '1000px')

        reduced_graph = self._adapt_nodes(network.graph)
        # populates the nodes and edges data structures
        nt.from_nx(reduced_graph)

        # The following 2 rows are potentially useful for configuring the pyvis graph: They are intended as temporary
        # for parameter setting only.
        # Warning: If you do (temporarily) uncomment out either of the following lines, the parameter control
        #   clashes with the legend (if _add_legend() is called).
        #nt.show_buttons(filter_=['physics'])
        #nt.show_buttons()

        nt.save_graph(self.filename)
        # Add the legend to the saved html file
        self._add_legend()

        if self.open_in_browser:
            webbrowser.open(self.filename)

    def _adapt_nodes(self, graph: nx.Graph):
        result = graph.copy()

        for node in list(result.nodes(data=True)):
            # Add the required info to the graph for rendering
            result.nodes[node[0]]['label'] = node[1]['node_obj'].household.id
            result.nodes[node[0]]['group'] = node[1]['node_obj'].node_type().value
            result.nodes[node[0]]['color'] = node_colours[node[1]['node_obj'].node_type()].colour
            result.nodes[node[0]]['title'] = node_colours[node[1]['node_obj'].node_type()].label

            # Remove the Node object from the graph node, as pyvis can't handle non JSON-serialisable objects
            node[1].pop('node_obj')

        for edge in result.edges.data():
            # For full set of edge settings, see: https://visjs.github.io/vis-network/docs/network/edges.html
            # Add the required info to the graph for rendering
            edge[2]['color'] = edge_colours[edge[2]['edge_type']].colour
            edge[2]['title'] = edge_colours[edge[2]['edge_type']].label

            # Too crowded (diagram) with labels on edges, but leaving in, in case required
            # edge[2]['label'] = edge_colours[edge[2]['edge_type']].label
            # edge[2]['font.size'] = '8'

            # Remove the Node object from the graph node, as pyvis can't handle non JSON-serialisable objects
            edge[2].pop('edge_type')

        return result

    def _add_legend(self):
        # load the file
        with open(self.filename) as inf:
            txt = inf.read()
            soup = bs(txt, "html.parser")

        # create new link
        new_table = soup.new_tag("table")
        # insert it into the document
        soup.body.append(new_table)

        # Edges legend
        new_row = soup.new_tag('tr')
        new_table.append(new_row)
        new_cell = soup.new_tag('th')
        new_row.append(new_cell)
        new_cell.string = 'Edges'
        for colour in edge_colours:
            new_row = soup.new_tag('tr')
            new_table.append(new_row)
            new_cell = soup.new_tag('td')
            new_row.append(new_cell)
            new_cell.string = edge_colours[colour].label
            new_cell = soup.new_tag('td')
            new_row.append(new_cell)
            new_cell['style'] = 'background-color:{}; width: 20px;'.format(edge_colours[colour].colour)

        # Nodes legend
        new_row = soup.new_tag('tr')
        new_table.append(new_row)
        new_cell = soup.new_tag('th')
        new_row.append(new_cell)
        new_cell.string = 'Nodes'
        for colour in node_colours:
            new_row = soup.new_tag('tr')
            new_table.append(new_row)
            new_cell = soup.new_tag('td')
            new_row.append(new_cell)
            new_cell.string = node_colours[colour].label
            new_cell = soup.new_tag('td')
            new_row.append(new_cell)
            new_cell['style'] = 'background-color:{}; width: 20px;'.format(node_colours[colour].colour)

        # save the file again
        with open(self.filename, "w") as outf:
            outf.write(str(soup))
